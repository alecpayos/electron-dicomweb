{"version":3,"file":"822.bundle.4b7c33c11240a5b37491.js","mappings":"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","sources":["webpack:///../../../extensions/measurement-tracking/src/viewports/TrackedCornerstoneViewport.tsx"],"sourcesContent":["import React, { useState, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport OHIF, { utils } from '@ohif/core';\n\nimport { ViewportActionBar, Tooltip, Icon } from '@ohif/ui';\n\nimport { useTranslation } from 'react-i18next';\n\nimport { annotation } from '@cornerstonejs/tools';\nimport { useTrackedMeasurements } from './../getContextModule';\nimport { BaseVolumeViewport, Enums } from '@cornerstonejs/core';\n\nconst { formatDate } = utils;\n\nfunction TrackedCornerstoneViewport(props) {\n  const { displaySets, viewportId, viewportLabel, servicesManager, extensionManager } = props;\n\n  const { t } = useTranslation('Common');\n\n  const { measurementService, cornerstoneViewportService, viewportGridService } =\n    servicesManager.services;\n\n  // Todo: handling more than one displaySet on the same viewport\n  const displaySet = displaySets[0];\n\n  const [trackedMeasurements, sendTrackedMeasurementsEvent] = useTrackedMeasurements();\n\n  const [isTracked, setIsTracked] = useState(false);\n  const [trackedMeasurementUID, setTrackedMeasurementUID] = useState(null);\n  const [viewportElem, setViewportElem] = useState(null);\n\n  const { trackedSeries } = trackedMeasurements.context;\n\n  const { SeriesDate, SeriesDescription, SeriesInstanceUID, SeriesNumber } = displaySet;\n\n  const {\n    PatientID,\n    PatientName,\n    PatientSex,\n    PatientAge,\n    SliceThickness,\n    SpacingBetweenSlices,\n    StudyDate,\n    ManufacturerModelName,\n  } = displaySet.images[0];\n\n  const updateIsTracked = useCallback(() => {\n    const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n\n    if (viewport instanceof BaseVolumeViewport) {\n      // A current image id will only exist for volume viewports that can have measurements tracked.\n      // Typically these are those volume viewports for the series of acquisition.\n      const currentImageId = viewport?.getCurrentImageId();\n\n      if (!currentImageId) {\n        if (isTracked) {\n          setIsTracked(false);\n        }\n        return;\n      }\n    }\n\n    if (trackedSeries.includes(SeriesInstanceUID) !== isTracked) {\n      setIsTracked(!isTracked);\n    }\n  }, [isTracked, trackedMeasurements, viewportId, SeriesInstanceUID]);\n\n  const onElementEnabled = useCallback(\n    evt => {\n      if (evt.detail.element !== viewportElem) {\n        // The VOLUME_VIEWPORT_NEW_VOLUME event allows updateIsTracked to reliably fetch the image id for a volume viewport.\n        evt.detail.element?.addEventListener(\n          Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n          updateIsTracked\n        );\n        setViewportElem(evt.detail.element);\n      }\n    },\n    [updateIsTracked, viewportElem]\n  );\n\n  const onElementDisabled = useCallback(() => {\n    viewportElem?.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, updateIsTracked);\n  }, [updateIsTracked, viewportElem]);\n\n  useEffect(updateIsTracked, [updateIsTracked]);\n\n  useEffect(() => {\n    const { unsubscribe } = cornerstoneViewportService.subscribe(\n      cornerstoneViewportService.EVENTS.VIEWPORT_DATA_CHANGED,\n      props => {\n        if (props.viewportId !== viewportId) {\n          return;\n        }\n\n        updateIsTracked();\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [updateIsTracked, viewportId]);\n\n  useEffect(() => {\n    if (isTracked) {\n      annotation.config.style.setViewportToolStyles(viewportId, {\n        global: {\n          lineDash: '',\n        },\n      });\n\n      cornerstoneViewportService.getRenderingEngine().renderViewport(viewportId);\n\n      return;\n    }\n\n    annotation.config.style.setViewportToolStyles(viewportId, {\n      global: {\n        lineDash: '4,4',\n      },\n    });\n\n    cornerstoneViewportService.getRenderingEngine().renderViewport(viewportId);\n\n    return () => {\n      annotation.config.style.setViewportToolStyles(viewportId, {});\n    };\n  }, [isTracked]);\n\n  /**\n   * The effect for listening to measurement service measurement added events\n   * and in turn firing an event to update the measurement tracking state machine.\n   * The TrackedCornerstoneViewport is the best place for this because when\n   * a measurement is added, at least one TrackedCornerstoneViewport will be in\n   * the DOM and thus can react to the events fired.\n   */\n  useEffect(() => {\n    const added = measurementService.EVENTS.MEASUREMENT_ADDED;\n    const addedRaw = measurementService.EVENTS.RAW_MEASUREMENT_ADDED;\n    const subscriptions = [];\n\n    [added, addedRaw].forEach(evt => {\n      subscriptions.push(\n        measurementService.subscribe(evt, ({ source, measurement }) => {\n          const { activeViewportId } = viewportGridService.getState();\n\n          // Each TrackedCornerstoneViewport receives the MeasurementService's events.\n          // Only send the tracked measurements event for the active viewport to avoid\n          // sending it more than once.\n          if (viewportId === activeViewportId) {\n            const { referenceStudyUID: StudyInstanceUID, referenceSeriesUID: SeriesInstanceUID } =\n              measurement;\n\n            sendTrackedMeasurementsEvent('SET_DIRTY', { SeriesInstanceUID });\n            sendTrackedMeasurementsEvent('TRACK_SERIES', {\n              viewportId,\n              StudyInstanceUID,\n              SeriesInstanceUID,\n            });\n          }\n        }).unsubscribe\n      );\n    });\n\n    return () => {\n      subscriptions.forEach(unsub => {\n        unsub();\n      });\n    };\n  }, [measurementService, sendTrackedMeasurementsEvent, viewportId, viewportGridService]);\n\n  function switchMeasurement(direction) {\n    const newTrackedMeasurementUID = _getNextMeasurementUID(\n      direction,\n      servicesManager,\n      trackedMeasurementUID,\n      trackedMeasurements\n    );\n\n    if (!newTrackedMeasurementUID) {\n      return;\n    }\n\n    setTrackedMeasurementUID(newTrackedMeasurementUID);\n\n    measurementService.jumpToMeasurement(viewportId, newTrackedMeasurementUID);\n  }\n\n  const getCornerstoneViewport = () => {\n    const { component: Component } = extensionManager.getModuleEntry(\n      '@ohif/extension-cornerstone.viewportModule.cornerstone'\n    );\n\n    return (\n      <Component\n        {...props}\n        onElementEnabled={onElementEnabled}\n        onElementDisabled={onElementDisabled}\n      />\n    );\n  };\n\n  return (\n    <>\n      <ViewportActionBar\n        onDoubleClick={evt => {\n          evt.stopPropagation();\n          evt.preventDefault();\n        }}\n        useAltStyling={isTracked}\n        onArrowsClick={direction => switchMeasurement(direction)}\n        getStatusComponent={() => _getStatusComponent(isTracked)}\n        studyData={{\n          label: viewportLabel,\n          studyDate: formatDate(SeriesDate) || formatDate(StudyDate) || t('NoStudyDate'),\n          currentSeries: SeriesNumber, // TODO - switch entire currentSeries to be UID based or actual position based\n          seriesDescription: SeriesDescription,\n          patientInformation: {\n            patientName: PatientName ? OHIF.utils.formatPN(PatientName) : '',\n            patientSex: PatientSex || '',\n            patientAge: PatientAge || '',\n            MRN: PatientID || '',\n            thickness: SliceThickness ? `${parseFloat(SliceThickness).toFixed(2)}` : '',\n            thicknessUnits: 'mm',\n            spacing:\n              SpacingBetweenSlices !== undefined\n                ? `${parseFloat(SpacingBetweenSlices).toFixed(2)}mm`\n                : '',\n            scanner: ManufacturerModelName || '',\n          },\n        }}\n      />\n      {/* TODO: Viewport interface to accept stack or layers of content like this? */}\n      <div className=\"relative flex h-full w-full flex-row overflow-hidden\">\n        {getCornerstoneViewport()}\n      </div>\n    </>\n  );\n}\n\nTrackedCornerstoneViewport.propTypes = {\n  displaySets: PropTypes.arrayOf(PropTypes.object.isRequired).isRequired,\n  viewportId: PropTypes.string.isRequired,\n  dataSource: PropTypes.object,\n  children: PropTypes.node,\n  customProps: PropTypes.object,\n};\n\nTrackedCornerstoneViewport.defaultProps = {\n  customProps: {},\n};\n\nfunction _getNextMeasurementUID(\n  direction,\n  servicesManager,\n  trackedMeasurementId,\n  trackedMeasurements\n) {\n  const { measurementService, viewportGridService } = servicesManager.services;\n  const measurements = measurementService.getMeasurements();\n\n  const { activeViewportId, viewports } = viewportGridService.getState();\n  const { displaySetInstanceUIDs: activeViewportDisplaySetInstanceUIDs } =\n    viewports.get(activeViewportId);\n\n  const { trackedSeries } = trackedMeasurements.context;\n\n  // Get the potentially trackable measurements for the series of the\n  // active viewport.\n  // The measurements to jump between are the same\n  // regardless if this series is tracked or not.\n\n  const filteredMeasurements = measurements.filter(\n    m =>\n      trackedSeries.includes(m.referenceSeriesUID) &&\n      activeViewportDisplaySetInstanceUIDs.includes(m.displaySetInstanceUID)\n  );\n\n  if (!filteredMeasurements.length) {\n    // No measurements on this series.\n    return;\n  }\n\n  const measurementCount = filteredMeasurements.length;\n\n  const uids = filteredMeasurements.map(fm => fm.uid);\n  let measurementIndex = uids.findIndex(uid => uid === trackedMeasurementId);\n\n  if (measurementIndex === -1) {\n    // Not tracking a measurement, or previous measurement now deleted, revert to 0.\n    measurementIndex = 0;\n  } else {\n    if (direction === 'left') {\n      measurementIndex--;\n\n      if (measurementIndex < 0) {\n        measurementIndex = measurementCount - 1;\n      }\n    } else if (direction === 'right') {\n      measurementIndex++;\n\n      if (measurementIndex === measurementCount) {\n        measurementIndex = 0;\n      }\n    }\n  }\n\n  const newTrackedMeasurementId = uids[measurementIndex];\n\n  return newTrackedMeasurementId;\n}\n\nfunction _getStatusComponent(isTracked) {\n  const trackedIcon = isTracked ? 'status-tracked' : 'status-untracked';\n\n  return (\n    <div className=\"relative\">\n      <Tooltip\n        position=\"bottom-left\"\n        content={\n          <div className=\"flex py-2\">\n            <div className=\"flex pt-1\">\n              <Icon\n                name=\"info-link\"\n                className=\"text-primary-main w-4\"\n              />\n            </div>\n            <div className=\"ml-4 flex\">\n              <span className=\"text-common-light text-base\">\n                {isTracked ? (\n                  <>\n                    Series is\n                    <span className=\"font-bold text-white\"> tracked</span> and can be viewed <br />{' '}\n                    in the measurement panel\n                  </>\n                ) : (\n                  <>\n                    Measurements for\n                    <span className=\"font-bold text-white\"> untracked </span>\n                    series <br /> will not be shown in the <br /> measurements panel\n                  </>\n                )}\n              </span>\n            </div>\n          </div>\n        }\n      >\n        <Icon\n          name={trackedIcon}\n          className=\"text-aqua-pale\"\n        />\n      </Tooltip>\n    </div>\n  );\n}\n\nexport default TrackedCornerstoneViewport;\n"],"names":["formatDate","utils","TrackedCornerstoneViewport","props","displaySets","viewportId","viewportLabel","servicesManager","extensionManager","t","useTranslation","measurementService","cornerstoneViewportService","viewportGridService","services","displaySet","trackedMeasurements","sendTrackedMeasurementsEvent","useTrackedMeasurements","isTracked","setIsTracked","useState","trackedMeasurementUID","setTrackedMeasurementUID","viewportElem","setViewportElem","trackedSeries","context","SeriesDate","SeriesDescription","SeriesInstanceUID","SeriesNumber","PatientID","PatientName","PatientSex","PatientAge","SliceThickness","SpacingBetweenSlices","StudyDate","ManufacturerModelName","images","updateIsTracked","useCallback","viewport","getCornerstoneViewport","BaseVolumeViewport","currentImageId","getCurrentImageId","includes","onElementEnabled","evt","detail","element","addEventListener","Enums","VOLUME_VIEWPORT_NEW_VOLUME","onElementDisabled","removeEventListener","useEffect","unsubscribe","subscribe","EVENTS","VIEWPORT_DATA_CHANGED","annotation","setViewportToolStyles","global","lineDash","getRenderingEngine","renderViewport","added","MEASUREMENT_ADDED","addedRaw","RAW_MEASUREMENT_ADDED","subscriptions","forEach","push","_ref","source","measurement","activeViewportId","getState","referenceStudyUID","StudyInstanceUID","referenceSeriesUID","unsub","React","ViewportActionBar","onDoubleClick","stopPropagation","preventDefault","useAltStyling","onArrowsClick","direction","newTrackedMeasurementUID","trackedMeasurementId","measurements","getMeasurements","viewports","displaySetInstanceUIDs","activeViewportDisplaySetInstanceUIDs","get","filteredMeasurements","filter","m","displaySetInstanceUID","length","measurementCount","uids","map","fm","uid","measurementIndex","findIndex","_getNextMeasurementUID","jumpToMeasurement","switchMeasurement","getStatusComponent","trackedIcon","className","Tooltip","position","content","Icon","name","_getStatusComponent","studyData","label","studyDate","currentSeries","seriesDescription","patientInformation","patientName","OHIF","formatPN","patientSex","patientAge","MRN","thickness","parseFloat","toFixed","thicknessUnits","spacing","undefined","scanner","component","Component","getModuleEntry","_extends","propTypes","PropTypes","isRequired","dataSource","children","customProps","defaultProps"],"sourceRoot":""}